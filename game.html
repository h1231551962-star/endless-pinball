<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>game</title>
<link rel="stylesheet" href="style.css">
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow-x: hidden; /* 防止左右滑动 */
}
canvas {
    display: block; /* 去掉默认 inline 间距 */
    max-width: 100%; /* canvas 最大宽度不超过屏幕 */
    height: auto;    /* 高度按比例缩放 */
}
</style>
</head>
<body>
  <div class="bg"></div>
        <div class="pixel-grid"></div>
    </div>

<!-- 短音效，预加载 auto -->
<audio id="click" src="click.mp3" preload="auto"></audio>
<audio id="cdown" src="countdown.mp3" preload="auto"></audio>
<audio id="lnch" src="launch.mp3" preload="auto"></audio>
<audio id="hit" src="hit.mp3" preload="auto"></audio>
<audio id="yay" src="yay.mp3" preload="auto"></audio>

<!-- 背景音乐 -->
<audio id="gstart" src="gamestart.mp3" preload="auto"></audio>
<audio id="gmain" src="gamemain.mp3" preload="auto" loop></audio>

<div id="modeBox" class="mode-box easy">简单模式</div>

<div id="scoreBox">得分: 0</div>

<canvas id="game" width="500" height="400"></canvas>

<script>
  
  window.onload = function() {
    const canvas = document.getElementById('game');
    const maxWidth = window.innerWidth;
    const scale = Math.min(1, maxWidth / 500);
    canvas.style.width = 500 * scale + 'px';
    canvas.style.height = 400 * scale + 'px';
};

/* 完整版：固定 500x400、倒计时、U 形炮台朝向与发射角一致、
   发射角严格在竖直向下 ±45°（45°~135°）、粒子与后坐力、淡出、边界反弹、底部才结束 */
const gmain = document.getElementById('gmain');
const click = document.getElementById('click');
const cdown = document.getElementById('cdown');
const gstart = document.getElementById('gstart');
const hitt = document.getElementById('hit');
const lnch = document.getElementById('lnch');
const yay = document.getElementById('yay');

// 难度切换示例
function setMode(mode) {
    const box = document.getElementById("modeBox");
    box.className = "mode-box"; // 清空旧 class

    if (mode === "easy") box.classList.add("easy");
    if (mode === "medium") box.classList.add("medium");
    if (mode === "hard") box.classList.add("hard");

    box.textContent = 
        mode === "easy" ? "简单模式" :
        mode === "medium" ? "中等模式" :
        "困难模式";
}

// 读取 URL 参数
function getDifficulty() {
    const params = new URLSearchParams(window.location.search);
    return params.get('difficulty') || 'easy'; // 默认 easy
}

const difficulty = getDifficulty();

setMode(difficulty);

let paddleWidth, ballSpeed;

switch(difficulty) {
    case 'easy':
        paddleWidth = 80;
        BALL_SPEED = 8;
        cannon_recoil = 6;
        spi = 0.00183;
        break;
    case 'medium':
        paddleWidth = 64;
        BALL_SPEED = 10.5;
        cannon_recoil = 9.5;
        spi =  0.0013;
        break;
    case 'hard':
        paddleWidth = 50;
        BALL_SPEED = 13;
        cannon_recoil = 13.5;
        spi = 0.0006056;
        break;
}

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

// 挡板（底部）
const paddle = {
  width: paddleWidth,
  height: 8,
  x: (W-paddleWidth)/2,
  y: H - 50,
  color: 'white'
};

// 炮台参数（上方）
const cannon = {
  x: W/2,
  y: 20,        // 顶部 20px
  radius: 22,   // U 外半径
  armDepth: 14, // U 两臂下降量
  angle: Math.PI/2, // 将会被设为 plannedAngle
  alpha: 1,
  recoil: 0
};

let score = 0;

function updateScoreDisplay() {
    const box = document.getElementById("scoreBox");
    box.textContent = "得分: " + score;

    if (score >= 30) {
        box.style.fontWeight = "bold"; // 加粗
        box.style.color = "orange";    // 橙色
    } else {
        box.style.fontWeight = "normal"; 
        box.style.color = "white";     // 或你默认颜色
    }
}
// 预定发射角度（在倒计时开始就确定）
let plannedAngle = null;

// 球对象
let ball = null;

// 粒子数组
let muzzleParticles = [];

// 倒计时
let countdown = 5;
let counting = true;

// 发射后淡出等参数
const waitBeforeFade = 2000;
const fadeDuration = 2800;

// 工具
function randRange(a,b){ return a + Math.random()*(b-a); }

// 在 45°~135°（竖直向下 ±45°）范围内采样角度（弧度）
function sampleLaunchAngle() {
  return Math.PI/4 + Math.random() * (Math.PI/2);
}

// 生成球（放在炮口外侧）
function spawnBall(angle) {
  const offset = cannon.radius + 8;
  const x = cannon.x + Math.cos(angle) * offset;
  const y = cannon.y + Math.sin(angle) * offset;
  return {
    x, y,
    radius: 9,
    vx: BALL_SPEED * Math.cos(angle),
    vy: BALL_SPEED * Math.sin(angle),
    color: 'red'
  };
}

// 画倒计时
function drawCountdown() {
  ctx.save();
  ctx.fillStyle = 'rgba(255, 255, 255, 0.45)';
  ctx.font = '56px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  const txt = countdown > 0 ? String(countdown) : '准备';
  ctx.fillText(txt, W/2, H/2);
  ctx.restore();
}

// 画挡板
function drawPaddle() {
  ctx.fillStyle = paddle.color;
  ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
}

// 画 U 形炮台（在本地坐标中开口朝下），旋转量为 (plannedAngle - π/2)
function drawCannon() {
  ctx.save();
  ctx.globalAlpha = cannon.alpha;

  // translate 到中心并应用后坐力沿发射方向的反向平移
  ctx.translate(cannon.x, cannon.y);
  const rot = cannon.angle - Math.PI/2; // 旋转使本地“向下”对应实际 plannedAngle
  // recoil 沿 -dir（即炮口方向的反向），所以先沿 -cos,-sin 移动
  ctx.translate(-Math.cos(cannon.angle) * cannon.recoil, -Math.sin(cannon.angle) * cannon.recoil);
  ctx.rotate(rot);

  // 绘制外形（平滑 U）
  const R = cannon.radius;
  const depth = cannon.armDepth;
  ctx.fillStyle = '#777';
  ctx.beginPath();
  // 左臂顶点
  ctx.moveTo(-R, 0);
  ctx.lineTo(-R, depth);
  ctx.quadraticCurveTo(0, depth + R*0.12, R, depth);
  ctx.lineTo(R, 0);
  // 顶部半圆（使上方更圆润）
  ctx.arc(0, 0, R, 0, Math.PI, true);
  ctx.closePath();
  ctx.fill();

  // 内壁（使像管道）
  ctx.beginPath();
  const innerR = R - 8;
  ctx.moveTo(-innerR, 0);
  ctx.lineTo(-innerR, depth - 4);
  ctx.quadraticCurveTo(0, depth - 4 + innerR*0.12, innerR, depth - 4);
  ctx.lineTo(innerR, 0);
  ctx.arc(0, 0, innerR, 0, Math.PI, true);
  ctx.fillStyle = '#ddd';
  ctx.fill();

  // 炮口小环（在本地坐标 y ~ depth）
  ctx.beginPath();
  ctx.fillStyle = '#333';
  ctx.ellipse(0, depth - 2, 6, 3, 0, 0, Math.PI*2);
  ctx.fill();

  ctx.restore();
}

// 发射粒子
function emitMuzzle(angle) {
  muzzleParticles.length = 0;
  const px = cannon.x + Math.cos(angle) * (cannon.radius + 2);
  const py = cannon.y + Math.sin(angle) * (cannon.radius + 2);
  const n = 12;
  for (let i=0;i<n;i++){
    const spread = 0.6;
    const a = angle + randRange(-spread, spread);
    const s = randRange(1.6, 3.2);
    muzzleParticles.push({
      x: px, y: py,
      vx: Math.cos(a)*s + randRange(-0.6,0.6),
      vy: Math.sin(a)*s + randRange(-0.6,0.6),
      life: 0, maxLife: randRange(18,36)
    });
  }
}

// 更新并绘制粒子
function updateAndDrawParticles() {
  if (muzzleParticles.length === 0) return;
  for (let p of muzzleParticles){
    p.x += p.vx; p.y += p.vy;
    p.vx *= 0.98; p.vy *= 0.98;
    p.life++;
  }
  for (let p of muzzleParticles){
    const t = p.life / p.maxLife;
    if (t>=1) continue;
    ctx.beginPath();
    ctx.globalAlpha = 1 - t;
    ctx.fillStyle = 'orange';
    ctx.arc(p.x, p.y, Math.max(1, 3*(1-t)), 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
  muzzleParticles = muzzleParticles.filter(p => p.life < p.maxLife);
}

// 画球
function drawBall() {
  if (!ball) return;
  ctx.beginPath();
  ctx.fillStyle = ball.color;
  ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2);
  ctx.fill();
}

// 更新球（边界反弹，挡板反弹，底部掉落结束）
// 初始化实时球速
let currentBallSpeed = BALL_SPEED;  // 当前球速，用于随时间加速
const speedIncrement = spi;       // 每帧自动增加的速度，可调整

function updateBall() {
    if (!ball) return;

    // 每帧让球速略微增加
    currentBallSpeed += speedIncrement;
    if (currentBallSpeed > BALL_SPEED * 2) {  // 设置上限，避免太快
        currentBallSpeed = BALL_SPEED * 2;
    }

    // 根据 currentBallSpeed 调整 vx, vy
    const speedRatio = currentBallSpeed / BALL_SPEED;
    ball.x += ball.vx * speedRatio;
    ball.y += ball.vy * speedRatio;

    // 左右反弹
    if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx = -ball.vx; }
    else if (ball.x + ball.radius > W) { ball.x = W - ball.radius; ball.vx = -ball.vx; }

    // 上边界反弹
    if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy = -ball.vy; }

    // 挡板碰撞
    if (
        ball.y + ball.radius >= paddle.y &&
        ball.y - ball.radius <= paddle.y + paddle.height &&
        ball.x >= paddle.x &&
        ball.x <= paddle.x + paddle.width
    ) {
        const paddleTop = paddle.y;
        const verticalMid = paddleTop + paddle.height / 2;
        const leftEdge = paddle.x + 4;
        const rightEdge = paddle.x + paddle.width - 4;

        // 竖直镜像反弹
        ball.vy = -Math.abs(ball.vy);

        // 水平速度微调：挡板移动叠加（蹭球效果）
        const padSpeed = paddle.speed || 0;
        const influence = 0.15;
        ball.vx += padSpeed * influence;

        // 上半边角落轻微拉偏
        const maxInfluence = 6;
        if (ball.y < verticalMid) {
            if (ball.x <= leftEdge) {
                ball.vx -= Math.min(maxInfluence, Math.abs(ball.vx) * 0.5 + 1);
            } else if (ball.x >= rightEdge) {
                ball.vx += Math.min(maxInfluence, Math.abs(ball.vx) * 0.5 + 1);
            }
        }

        // 防止球粘在挡板上
        if (ball.y + ball.radius > paddle.y) {
            ball.y -= (ball.y + ball.radius - paddle.y) * 0.5;
        }
        // 增加一点随机反弹，避免单调
        const randomAngle = (Math.random() - 0.5) * 0.2; // -0.1 ~ 0.1 弧度
        ball.vx += randomAngle * BALL_SPEED;

            // 播放碰撞音效
        const hitInstance = hitt.cloneNode(); // 克隆一个新的音频实例
        hitInstance.play();

        // 延迟加分
        setTimeout(() => {
            score++;
        updateScoreDisplay();
        
        // 达到 30 分播放 yay 音效
        if (score === 30) {
            yay.volume = 1.0;
            yay.currentTime = 0;
            yay.play();
        }
    }, 75);
    }

    // 底部掉落结束
    if (ball.y - ball.radius > H) {
        ball = null;

        // 获取当前难度参数
        const urlParams = new URLSearchParams(window.location.search);
        const difficulty = urlParams.get('difficulty') || 'easy';

        // 跳转到游戏结束页面，并带上难度和得分
        window.location.href = `settlement.html?difficulty=${difficulty}&score=${score}`;
        return;
    }
}

// 临时改变球速并恢复
function changeBallSpeed(tempSpeed, duration) {
    currentBallSpeed = tempSpeed;
    setTimeout(() => {
        currentBallSpeed = BALL_SPEED;
    }, duration);
}

// 执行发射（倒计时结束时调用） —— 使用事先确定的 plannedAngle
let cannonFadeRAF = null;     // 存淡出动画的 requestAnimationFrame ID
let cannonFadeTimeout = null; // 存淡出延时 setTimeout ID

function startBackgroundMusic() {
    gmain.currentTime = 0;
    gmain.volume = 0.8;   // 设置较小音量（0~1）
    gmain.loop = true;    // 循环播放
    gmain.play();
}

// 在 doLaunch 调用后延迟 1 秒播放
function doLaunch() {
    const angle = plannedAngle;
    cannon.angle = angle;
    ball = spawnBall(angle);
    emitMuzzle(angle);

    // 简单后坐力动画（原有逻辑）
    const recoilDecay = setInterval(()=>{
        cannon.recoil *= 0.72;
        if (cannon.recoil < 0.05) { 
            cannon.recoil = 0; 
            clearInterval(recoilDecay); 
        }
    }, 30);

    // 延时淡出动画（原有逻辑）
    if (cannonFadeRAF) {
        cancelAnimationFrame(cannonFadeRAF);
        cannonFadeRAF = null;
    }
    if (cannonFadeTimeout) {
        clearTimeout(cannonFadeTimeout);
        cannonFadeTimeout = null;
    }

    cannonFadeTimeout = setTimeout(() => {
        const start = performance.now();
        const duration = fadeDuration;
        const initialY = cannon.y;
        const initialAlpha = cannon.alpha !== undefined ? cannon.alpha : 1;
        const targetY = initialY - (canvas.height + 50);

        function step(now) {
            const tRaw = Math.min(1, (now - start) / duration);
            const t = 1 - Math.pow(1 - tRaw, 3);
            cannon.y = initialY + (targetY - initialY) * t;
            cannon.alpha = initialAlpha * (1 - t);

            if (tRaw < 1) {
                cannonFadeRAF = requestAnimationFrame(step);
            } else {
                cannon.y = targetY;
                cannon.alpha = 0;
                cannonFadeRAF = null;
            }
        }

        cannonFadeRAF = requestAnimationFrame(step);
    }, waitBeforeFade);

    // ✅ 倒计时结束、发射后 1 秒开始播放背景音乐
    setTimeout(startBackgroundMusic, 1000);
}

// 倒计时开始
function startCountdown() {
  // 取消残留动画（防止干扰下一轮）
  if (cannonFadeRAF) {
    cancelAnimationFrame(cannonFadeRAF);
    cannonFadeRAF = null;
  }
  if (cannonFadeTimeout) {
    clearTimeout(cannonFadeTimeout);
    cannonFadeTimeout = null;
  }

  // 重置炮台状态
  cannon.y = 20;
  cannon.alpha = 1;
  cannon.recoil = 0;

  // 先播放游戏开始音乐
  gstart.currentTime = 0;
  gstart.play();

  countdown = 5;
  counting = true;

  // 预定发射角度
  plannedAngle = sampleLaunchAngle();
  cannon.angle = plannedAngle;

  const tId = setInterval(() => {
    if (countdown > 0) {
      // 播放倒计时音效（克隆音频，避免延迟或被打断）
      const cdownInstance = cdown.cloneNode();
      cdownInstance.play();
    }

    countdown--;
    if (countdown < 0) {
      clearInterval(tId);
      counting = false;

      // 倒计时结束，发射球
      doLaunch();
      // 播放发射音效（克隆音频，确保零延迟）
      const lnchInstance = lnch.cloneNode();
      lnchInstance.play();
      
    }
  }, 1000);
}

// 游戏结束时调用
function gameOver() {
  // 停止球
  ball = null;

  // 取消残留动画
  if (cannonFadeRAF) { cancelAnimationFrame(cannonFadeRAF); cannonFadeRAF = null; }
  if (cannonFadeTimeout) { clearTimeout(cannonFadeTimeout); cannonFadeTimeout = null; }

  // 重置炮台
  cannon.y = 20;
  cannon.alpha = 1;
  cannon.recoil = 0;

  alert("游戏结束！");
  startCountdown();
}

// 鼠标/触摸控制挡板
canvas.addEventListener('mousemove', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  paddle.x = Math.max(0, Math.min(W - paddle.width, mx - paddle.width/2));
});
canvas.addEventListener('touchmove', (e)=>{
  if (!e.touches || e.touches.length === 0) return;
  const rect = canvas.getBoundingClientRect();
  const mx = e.touches[0].clientX - rect.left;
  paddle.x = Math.max(0, Math.min(W - paddle.width, mx - paddle.width/2));
  e.preventDefault();
}, {passive:false});

// 主循环
function loop() {
  ctx.clearRect(0,0,W,H);

  // 绘制顺序：挡板 -> 炮台 -> 粒子 -> 球 -> 倒计时
  drawPaddle();
  drawCannon();
  updateAndDrawParticles();
  drawBall();
  if (counting) drawCountdown();
  if (ball) updateBall();

  requestAnimationFrame(loop);
}

// 启动
startCountdown();
loop();

</script>

</body>
</html>
